#! /usr/bin/env bash

RED="\e[31m"
GREEN="\e[32m"
EC="\e[0m"

KUBECONFIG="${kubeconfig_path}"
KUBECONFIG_PROXY="$KUBECONFIG-proxy"

open_ssh_tunnel_to_k8s_api() {
  TUNNEL_SOCKET_FILE=$${TUNNEL_SOCKET_FILE:-/tmp/k8s-tunnel-socket}
  printf "$GREEN Openning k8s tunnel ... $EC \n"
  ssh -q -N -f -M -o "StrictHostKeyChecking no" -o "ExitOnForwardFailure=yes" -i "${ssh_pvt_key_path}" -D ${k8s_tunnel_port} -S "$TUNNEL_SOCKET_FILE" ${bastion_user}@${bastion_public_ip}
}

check_kubeconfig() {
  printf "$GREEN Checking if $KUBECONFIG exists... $EC \n"
  if test -f "$KUBECONFIG"; then
    echo "$KUBECONFIG exists, creating $KUBECONFIG_PROXY for proxy use."
    cp $KUBECONFIG $KUBECONFIG_PROXY
    kubectl --kubeconfig $KUBECONFIG_PROXY config set "clusters.${eks_cluster_arn}.proxy-url" "socks5://127.0.0.1:${k8s_tunnel_port}"
  else
    echo "$KUBECONFIG does not exist." && exit 1
  fi
  echo
}

set_k8s_auth() {
  local AWS_AUTH_YAML="${aws_auth_yaml}"
  if test -f "$AWS_AUTH_YAML"; then
    printf "$GREEN Updating $AWS_AUTH_YAML... $EC \n"
    kubectl_apply "$AWS_AUTH_YAML"
  else
    printf "$RED $AWS_AUTH_YAML does not exist. $EC \n" && exit 1
  fi
  echo
}

set_eniconfig() {
  local ENICONFIG_YAML="${eniconfig_yaml}"
  if [ -z "$ENICONFIG_YAML" ]; then
    return
  fi
  if test -f "$ENICONFIG_YAML"; then
    printf "$GREEN Updating $ENICONFIG_YAML... $EC \n"
    kubectl_apply "$ENICONFIG_YAML"
  else
    printf "$RED $ENICONFIG_YAML does not exist. $EC \n" && exit 1
  fi
  echo
  kubectl_cmd -n kube-system set env daemonset aws-node AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG=true ENI_CONFIG_LABEL_DEF=topology.kubernetes.io/zone
}

install_calico() {
  local CALICO_OPERATOR_YAML_URL=${calico_operator_url}
  printf "$GREEN Installing Calico Operator $EC \n"
  ## Workaround for https://github.com/projectcalico/calico/issues/6491#issuecomment-1253970628
  (kubectl_cmd create -f $CALICO_OPERATOR_YAML_URL) || true
  kubectl_cmd replace -f $CALICO_OPERATOR_YAML_URL
  echo

  printf "$GREEN Installing Calico Custom resources $EC \n"
  kubectl_cmd create -f - <<EOF
kind: Installation
apiVersion: operator.tigera.io/v1
metadata:
  name: default
spec:
  kubernetesProvider: EKS
  cni:
    type: AmazonVPC
EOF
  echo
}

validate_url() {
  local url="$1"
  local log_file="validate-url.log"
  if curl --head --fail --max-time 10 --output "$log_file" --stderr "$log_file" "$url"; then
    rm "$log_file" && return 0
  else
    cat "$log_file" && return 1
  fi
}

kubectl_apply() {
  local k8s_manifest="$1"
  if test -f "$k8s_manifest" || validate_url "$k8s_manifest"; then
    echo "Applying $k8s_manifest..."
    kubectl --kubeconfig "$KUBECONFIG_PROXY" apply -f "$k8s_manifest"
    if [ $? -ne 0 ]; then
      printf "$RED Error applying $k8s_manifest \n"
      exit 1
    fi
  else
    printf "$RED $k8s_manifest does not exist. $EC \n"
    exit 1
  fi
}

kubectl_cmd() {
  echo "Running kubectl $@..."
  kubectl --kubeconfig "$KUBECONFIG_PROXY" $@
  if [ $? -ne 0 ]; then
    printf "$RED Error running kubectl $@ $EC \n"
    exit 1
  fi
}

close_ssh_tunnel_to_k8s_api() {
  printf "$GREEN Shutting down k8s tunnel ... $EC"
  ssh -S $TUNNEL_SOCKET_FILE -O exit ${bastion_user}@${bastion_public_ip}
}
